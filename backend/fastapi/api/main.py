from fastapi import FastAPI, Request
import asyncio
import logging
import uuid
import time
from pathlib import Path
from contextlib import asynccontextmanager
from fastapi.responses import FileResponse
# Triggering reload for new community routes
from fastapi.middleware.cors import CORSMiddleware
from fastapi.middleware.gzip import GZipMiddleware
from starlette.middleware.base import BaseHTTPMiddleware
from .config import get_settings_instance
from .api.v1.router import api_router as api_v1_router
from .routers.health import router as health_router
from .utils.limiter import limiter
from slowapi import _rate_limit_exceeded_handler
from slowapi.errors import RateLimitExceeded

# Load and validate settings on import
settings = get_settings_instance()
STATIC_DIR = Path(__file__).resolve().parent / "static"
FAVICON_PATH = STATIC_DIR / "favicon.svg"

# Initialize FastAPI Cache early (before router imports)
try:
    import redis.asyncio as redis
    redis_client = redis.from_url(
        settings.redis_url,
        encoding="utf-8",
        decode_responses=True
    )
    from fastapi_cache import FastAPICache
    from fastapi_cache.backends.redis import RedisBackend
    FastAPICache.init(RedisBackend(redis_client), prefix="fastapi-cache")
    print("[OK] FastAPI Cache initialized with Redis backend")
except Exception as e:
    print(f"[WARNING] FastAPI Cache initialization failed: {e}")
    # Initialize with in-memory backend as fallback
    try:
        from fastapi_cache import FastAPICache
        from fastapi_cache.backends.memory import MemoryBackend
        FastAPICache.init(MemoryBackend(), prefix="fastapi-cache")
        print("[OK] FastAPI Cache initialized with in-memory backend")
    except Exception as e2:
        print(f"[ERROR] FastAPI Cache fallback initialization failed: {e2}")


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Application lifespan context manager for startup and shutdown events."""
    logger = logging.getLogger("api.lifespan")
    
    # STARTUP LOGIC
    logger.info("LIFESPAN BOOT STARTED")
    
    app.state.settings = settings
    
    # Generate a unique instance ID for this server session
    # All JWTs will include this ID; tokens from previous instances are rejected
    app.state.server_instance_id = str(uuid.uuid4())
    print(f"[OK] Server instance ID: {app.state.server_instance_id}")
    
    # Initialize database tables
    try:
        from .services.db_service import Base, engine, SessionLocal
        Base.metadata.create_all(bind=engine)
        print("[OK] Database tables initialized/verified")
        
        # Verify database connectivity before starting background tasks
        with SessionLocal() as db:
            from sqlalchemy import text
            db.execute(text("SELECT 1"))
            print("[OK] Database connectivity verified")
        
        # Initialize Redis for rate limiting
        try:
            import redis.asyncio as redis
            redis_client = redis.from_url(
                settings.redis_url,
                encoding="utf-8",
                decode_responses=True
            )
            # Test Redis connectivity
            await redis_client.ping()
            app.state.redis_client = redis_client
            
            # Configure slowapi limiter with Redis storage
            limiter._storage_uri = settings.redis_url
            print(f"[OK] Redis connected for rate limiting: {settings.redis_host}:{settings.redis_port}")
            
        except Exception as e:
            logger.warning(f"Redis initialization failed: {e}")
            print(f"[WARNING] Redis not available, rate limiting will use in-memory fallback: {e}")
            # SlowAPI will automatically fall back to in-memory storage if Redis is unavailable
            
        # Initialize analytics scheduler
        try:
            from app.ml.scheduler_service import get_scheduler
            scheduler = get_scheduler()
            scheduler.start()
            app.state.analytics_scheduler = scheduler
            print("[OK] Analytics scheduler initialized and started")
        except Exception as e:
            logger.warning(f"Analytics scheduler initialization failed: {e}")
            print(f"[WARNING] Analytics scheduler not available: {e}")
        
        # Start background task for soft-delete cleanup
        async def purge_task_loop():
            while True:
                try:
                    print("[CLEANUP] Starting scheduled purge of expired accounts...")
                    with SessionLocal() as db:
                        from .services.user_service import UserService
                        user_service = UserService(db)
                        user_service.purge_deleted_users(settings.deletion_grace_period_days)
                    print("[CLEANUP] Scheduled purge completed successfully")
                except Exception as e:
                    logger = logging.getLogger("api.purge_task")
                    logger.error(f"Soft-delete cleanup task failed: {e}", exc_info=True)
                    # Continue the loop instead of crashing - the task will retry in 24 hours
                
                # Run once every 24 hours
                await asyncio.sleep(24 * 3600)
        
        purge_task = asyncio.create_task(purge_task_loop())
        app.state.purge_task = purge_task  # Store reference for cleanup
        print("[OK] Soft-delete cleanup task scheduled (runs every 24h)")
        
    except Exception as e:
        print(f"[ERROR] Database initialization failed: {e}")
        # Re-raise to crash the application - don't start with broken DB
        raise
    
    logger.info("Application startup completed successfully")
    
    yield  # API processes requests here
    
    # SHUTDOWN LOGIC
    logger.info("LIFESPAN TEARDOWN STARTED")
    
    # Cancel background tasks
    if hasattr(app.state, 'purge_task'):
        logger.info("Cancelling background purge task...")
        app.state.purge_task.cancel()
        try:
            await app.state.purge_task
        except asyncio.CancelledError:
            logger.info("Background purge task cancelled successfully")
    
    # Stop analytics scheduler
    if hasattr(app.state, 'analytics_scheduler'):
        logger.info("Stopping analytics scheduler...")
        app.state.analytics_scheduler.stop()
        logger.info("Analytics scheduler stopped successfully")
    
    # Close Redis connection
    if hasattr(app.state, 'redis_client'):
        logger.info("Closing Redis connection...")
        try:
            await app.state.redis_client.close()
            logger.info("Redis connection closed successfully")
        except Exception as e:
            logger.error(f"Error closing Redis connection: {e}")
    
    # Dispose database engine if needed
    try:
        from .services.db_service import engine
        logger.info("Disposing database engine...")
        await engine.dispose()
        logger.info("Database engine disposed successfully")
    except Exception as e:
        logger.error(f"Error disposing database engine: {e}")
    
    logger.info("Application shutdown completed")


class VersionHeaderMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        response = await call_next(request)
        response.headers["X-API-Version"] = "1.0"
        return response


class PerformanceMonitoringMiddleware(BaseHTTPMiddleware):
    """
    Middleware to track API response times and performance metrics.
    Logs slow requests and adds performance headers.
    """
    async def dispatch(self, request: Request, call_next):
        start_time = time.time()

        # Process request
        response = await call_next(request)

        # Calculate duration
        process_time = (time.time() - start_time) * 1000  # Convert to milliseconds

        # Add performance header
        response.headers["X-Process-Time"] = f"{process_time:.2f}"

        # Log slow requests (> 500ms)
        if process_time > 500:
            logger = logging.getLogger("api.performance")
            logger.warning(
                f"Slow request: {request.method} {request.url.path} took {process_time:.2f}ms"
            )

        # Log all requests in debug mode
        settings = get_settings_instance()
        if settings.debug:
            logger = logging.getLogger("api.requests")
            logger.info(
                f"{request.method} {request.url.path} - Status: {response.status_code} - Time: {process_time:.2f}ms"
            )

        return response


def create_app() -> FastAPI:
    app = FastAPI(
        title="SoulSense API",
        description="Comprehensive REST API for SoulSense EQ Test Platform",
        version="1.0.0",
        docs_url="/docs",
        redoc_url="/redoc",
        lifespan=lifespan
    )

    @app.get("/favicon.ico", include_in_schema=False)
    async def favicon():
        return FileResponse(FAVICON_PATH, media_type="image/svg+xml")

    # Attach slowapi limiter
    app.state.limiter = limiter
    app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

    # Request Logging Middleware (inner-most for full request lifecycle tracking)
    # Provides: Request IDs, JSON logging, PII protection, X-Request-ID headers
    from .middleware.logging_middleware import RequestLoggingMiddleware
    app.add_middleware(RequestLoggingMiddleware)

    # GZip compression middleware for response optimization
    app.add_middleware(GZipMiddleware, minimum_size=1000, compresslevel=6)

    # Security Headers Middleware
    from .middleware.security import SecurityHeadersMiddleware
    app.add_middleware(SecurityHeadersMiddleware)

    # Consent Validation Middleware for privacy compliance
    # Blocks analytics data collection without user consent
    from .middleware.consent_middleware import ConsentValidationMiddleware
    app.add_middleware(ConsentValidationMiddleware)

    # ETag Middleware for HTTP caching optimization
    # Adds ETag headers to static resources (questions, prompts, translations)
    # Returns 304 Not Modified when content hasn't changed, saving bandwidth
    from .middleware.etag_middleware import ETagMiddleware
    app.add_middleware(ETagMiddleware)

    # CORS middleware
    # In debug mode, allow all origins for easier development
    if settings.debug:
        origins = ["*"]
        allow_credentials = False  # Must be False when using wildcard origins
    else:
        origins = settings.BACKEND_CORS_ORIGINS
        allow_credentials = True
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=origins,
        allow_credentials=allow_credentials,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
        allow_headers=["Content-Type", "Authorization", "Accept", "Origin", "X-Requested-With"],
        expose_headers=["X-API-Version", "X-Request-ID", "X-Process-Time", "ETag"],  # Expose request ID for frontend tracing
        max_age=3600,  # Cache preflight requests for 1 hour
    )
    
    # Version header middleware
    app.add_middleware(VersionHeaderMiddleware)
    
    # Mount static files for avatars
    from fastapi.staticfiles import StaticFiles
    import os
    avatars_path = os.path.join(os.getcwd(), "app_data", "avatars")
    os.makedirs(avatars_path, exist_ok=True)
    app.mount("/api/v1/avatars", StaticFiles(directory=avatars_path), name="avatars")

    # Register V1 API Router
    app.include_router(api_v1_router, prefix="/api/v1")

    # Register Health endpoints at root level for orchestration
    app.include_router(health_router, tags=["Health"])

        # Register standardized exception handlers
    from backend.fastapi.app.core import register_exception_handlers
    register_exception_handlers(app)


    # Root endpoint - version discovery
    @app.get("/", tags=["Root"])
    async def root():
        return {
            "name": "SoulSense API",
            "versions": [
                {"version": "v1", "status": "current", "path": "/api/v1"}
            ],
            "documentation": "/docs"
        }

    print("[OK] SoulSense API started successfully")
    print(f"[ENV] Environment: {settings.app_env}")
    print(f"[CONFIG] Debug mode: {settings.debug}")
    print(f"[DB] Database: {settings.database_url}")
    print(f"[API] API available at /api/v1")

    # OUTSIDE MIDDLEWARES (added last to run first)
    
    # Host Header Validation
    from fastapi.middleware.trustedhost import TrustedHostMiddleware
    print(f"[SECURITY] Loading TrustedHostMiddleware with allowed_hosts: {settings.ALLOWED_HOSTS}")
    app.add_middleware(
        TrustedHostMiddleware, 
        allowed_hosts=settings.ALLOWED_HOSTS
    )

    return app


app = create_app()
